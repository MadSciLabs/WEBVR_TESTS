<!DOCTYPE html>
<html lang="en">

<head>
	<title>Test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>
	<script src="/build/three.js"></script>
	<script src="/js/loaders/PLYLoader.js"></script>

	<script src="/js/Detector.js"></script>
	<script src="/js/libs/stats.min.js"></script>


	<script>
		var camera, scene, renderer;
		var cube, sphere, torus, alex, material;

		var cubeCamera, textureCube;

		var fov = 60,
			isUserInteracting = false,
			onMouseDownMouseX = 0,
			onMouseDownMouseY = 0,
			lon = 0,
			onMouseDownLon = 0,
			lat = 0,
			onMouseDownLat = 0,
			phi = 0,
			theta = 0;

		var textureLoader = new THREE.TextureLoader();

		textureLoader.load('textures/2294472375_24a3b8ef46_o.jpg', function(texture) {
			texture.mapping = THREE.UVMapping;
			init(texture);
			animate();
		});

		function init(texture) {

			camera = new THREE.PerspectiveCamera(fov, window.innerWidth / window.innerHeight, 1, 1000);

			scene = new THREE.Scene();

			//cube background
			var textureCube = new THREE.CubeTextureLoader()
				.setPath('textures/cube/Bridge2/')
				.load(['posx.jpg', 'negx.jpg', 'posy.jpg', 'negy.jpg', 'posz.jpg', 'negz.jpg']);
			scene = new THREE.Scene();
			scene.background = textureCube;

			//mesh background
			// var mesh = new THREE.Mesh(new THREE.SphereGeometry(500, 32, 16), new THREE.MeshBasicMaterial({
			// 	map: texture
			// 	//color: 0x0f0f0f
			// }));
			// mesh.scale.x = -1;
			// scene.add(mesh);

			// cubeCamera = new THREE.CubeCamera(1, 1000, 256);
			// cubeCamera.renderTarget.texture.minFilter = THREE.LinearMipMapLinearFilter;
			// scene.add(cubeCamera);
			// textureCube = cubeCamera.renderTarget.texture;

			// LIGHTS
			var ambient = new THREE.AmbientLight(0x050505);
			scene.add(ambient);
			directionalLight = new THREE.DirectionalLight(0xffffff, 2);
			directionalLight.position.set(2, 1.2, 10).normalize();
			scene.add(directionalLight);
			directionalLight = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight.position.set(-2, 1.2, -10).normalize();
			scene.add(directionalLight);
			pointLight = new THREE.PointLight(0xffaa00, 2);
			pointLight.position.set(2000, 1200, 10000);
			scene.add(pointLight);

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			document.body.appendChild(renderer.domElement);

			var mlib = {
				"Carmine": new THREE.MeshPhongMaterial({
					color: 0x770000,
					specular: 0xffaaaa,
					envMap: textureCube,
					combine: THREE.MultiplyOperation
				}),
				"Gold": new THREE.MeshPhongMaterial({
					color: 0xaa9944,
					specular: 0xbbaa99,
					shininess: 50,
					envMap: textureCube,
					combine: THREE.MultiplyOperation
				}),
				"Bronze": new THREE.MeshPhongMaterial({
					color: 0x150505,
					specular: 0xee6600,
					shininess: 10,
					envMap: textureCube,
					combine: THREE.MixOperation,
					reflectivity: 0.25
				}),
				"Chrome": new THREE.MeshPhongMaterial({
					color: 0xffffff,
					specular: 0xffffff,
					envMap: textureCube,
					combine: THREE.MultiplyOperation
				}),
				"Silver": new THREE.MeshPhongMaterial({
					envMap: textureCube
				})
			};

			material = mlib["Bronze"];

			cube = new THREE.Mesh(new THREE.BoxGeometry(20, 20, 20), material);
			scene.add(cube);

			torus = new THREE.Mesh(new THREE.TorusKnotGeometry(10, 5, 100, 25), mlib["Gold"]);
			scene.add(torus);

			var loader = new THREE.PLYLoader();
			loader.load('/models/ply/Alex_Wood.ply', function(geometry) {
				geometry.computeVertexNormals();

				//vertex colors
				/*
				material = new THREE.MeshStandardMaterial({
				color: 0x0055ff,
				vertexColors: THREE.VertexColors,
				// shading: THREE.FlatShading
				color: 0xffffff,
				specular: 0x111111,
				shininess: 100,
				vertexColors: THREE.VertexColors
				});
				*/


				alex = new THREE.Mesh(geometry, material);

				alex.position.x = -100.4;
				alex.position.y = -200.4;
				alex.position.z = -100.3;

				alex.rotation.x = -Math.PI / 2;
				alex.scale.multiplyScalar(0.2);
				alex.castShadow = true;
				alex.receiveShadow = true;
				scene.add(alex);
			});



			document.addEventListener('mousedown', onDocumentMouseDown, false);
			document.addEventListener('wheel', onDocumentMouseWheel, false);
			window.addEventListener('resize', onWindowResized, false);

			onWindowResized(null);

		}

		function onWindowResized(event) {
			renderer.setSize(window.innerWidth, window.innerHeight);
			camera.projectionMatrix.makePerspective(fov, window.innerWidth / window.innerHeight, 1, 1100);
		}

		function onDocumentMouseDown(event) {
			event.preventDefault();

			onPointerDownPointerX = event.clientX;
			onPointerDownPointerY = event.clientY;

			onPointerDownLon = lon;
			onPointerDownLat = lat;

			document.addEventListener('mousemove', onDocumentMouseMove, false);
			document.addEventListener('mouseup', onDocumentMouseUp, false);

		}

		function onDocumentMouseMove(event) {

			lon = (event.clientX - onPointerDownPointerX) * 0.1 + onPointerDownLon;
			lat = (event.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;

		}

		function onDocumentMouseUp(event) {

			document.removeEventListener('mousemove', onDocumentMouseMove, false);
			document.removeEventListener('mouseup', onDocumentMouseUp, false);

		}

		function onDocumentMouseWheel(event) {

			fov += event.deltaY * 0.05;

			camera.projectionMatrix.makePerspective(fov, window.innerWidth / window.innerHeight, 1, 1100);

		}

		function animate() {

			requestAnimationFrame(animate);
			render();

		}

		function render() {

			var time = Date.now();

			lon += .15;

			lat = Math.max(-85, Math.min(85, lat));
			phi = THREE.Math.degToRad(90 - lat);
			theta = THREE.Math.degToRad(lon);

			cube.position.x = Math.cos(time * 0.001) * 30;
			cube.position.y = Math.sin(time * 0.001) * 30;
			cube.position.z = Math.sin(time * 0.001) * 30;

			cube.rotation.x += 0.02;
			cube.rotation.y += 0.03;

			torus.position.x = Math.cos(time * 0.001 + 10) * 30;
			torus.position.y = Math.sin(time * 0.001 + 10) * 30;
			torus.position.z = Math.sin(time * 0.001 + 10) * 30;

			torus.rotation.x += 0.02;
			torus.rotation.y += 0.03;

			camera.position.x = 100 * Math.sin(phi) * Math.cos(theta);
			camera.position.y = 100 * Math.cos(phi);
			camera.position.z = 100 * Math.sin(phi) * Math.sin(theta);

			camera.lookAt(scene.position);

			//cubeCamera.updateCubeMap(renderer, scene);

			renderer.render(scene, camera);

		}
	</script>

</body>

</html>
